local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local lplr = Players.LocalPlayer
local camera = Workspace.CurrentCamera

local settings = {
    Enabled = true,
    FOV = 700,
    TargetPart = "Head",
    MaxHeight = 500
}

-- [1] DATA STORAGE
local currentTarget = nil
local fovCircle = Drawing.new("Circle")
fovCircle.Visible = true
fovCircle.Thickness = 1
fovCircle.NumSides = 64
fovCircle.Radius = settings.FOV
fovCircle.Color = Color3.fromRGB(255, 255, 255)

-- [2] SCANNER (Orbit Logic)
RunService.RenderStepped:Connect(function()
    local mouseLoc = UserInputService:GetMouseLocation()
    fovCircle.Position = mouseLoc
    local closest, shortestDist = nil, settings.FOV

    pcall(function()
        for _, model in pairs(Workspace:GetChildren()) do
            -- Handles both loose players and the 'Bots' folder
            local targets = (model.Name == "Bots") and model:GetChildren() or {model}
            for _, target in pairs(targets) do
                if target:IsA("Model") and target ~= lplr.Character then
                    local head = target:FindFirstChild(settings.TargetPart)
                    local hum = target:FindFirstChildOfClass("Humanoid")
                    if head and head:FindFirstChild("Teammate") then continue end
                    if head and hum and hum.Health > 0 and head.Position.Y < settings.MaxHeight then
                        local screenPos, onScreen = camera:WorldToViewportPoint(head.Position)
                        if onScreen then
                            local dist = (Vector2.new(screenPos.X, screenPos.Y) - mouseLoc).Magnitude
                            if dist < shortestDist then
                                shortestDist = dist
                                closest = head
                            end
                        end
                    end
                end
            end
        end
    end)
    currentTarget = closest
    fovCircle.Color = currentTarget and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 255, 255)
end)

-- [3] THE HOOK
-- This hooks the actual engine method to ensure the Ray is valid
local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", function(self, ...)
    local method = getnamecallmethod()
    local args = {...}

    if not checkcaller() and settings.Enabled and currentTarget then
        -- Hooking the Camera methods specifically
        if self == camera and (method == "ViewportPointToRay" or method == "ScreenPointToRay") then
            -- 1. Call the original function to get a valid Ray object
            local originalRay = oldNamecall(self, unpack(args))
            
            -- 2. Create the modified direction from Camera to Head
            local newDirection = (currentTarget.Position - originalRay.Origin).Unit
            
            -- 3. Return a new Ray that starts at the Camera but hits the Head
            return Ray.new(originalRay.Origin, newDirection)
        end
    end

    return oldNamecall(self, unpack(args))
end)

print(":: GhavesHead-Lock Active Enjoy ::")
